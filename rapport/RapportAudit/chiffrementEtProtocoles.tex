\chapter{Chiffrement et Protocoles}

\section{Définitions et contexte}

A remplir.

\section{Audits}
	\subsection{Audit 1 : Les "Manger's attack" sur RSA-OAEP}
		\subsubsection{Normes visées}

		A remplir	
	
		\subsubsection{Faille}
		
			RSA-OAEP peut être soumis à une attaque nommée "Mangers Attack" selon son implantation \cite{mangers2010falko}. OpenSSL semble être vulnérable à une attaque de ce type, à base de "prédictions" par injections de fautes. La vulnérabilité semble être très récente puisqu'elle fonctionne sous OpenSSL 1.0.0.\\

			
			Le padding OAEP devait pallier le problème d'insécurité que causait le padding PKCS\#1 v1.5 (attaque à chiffré choisi) \cite{bleichenbacherPCKS}. OpenSSL a tout de même pris en compte cette vulnérabilité et a placé des contres-mesures efficaces.	La Technische Universität Darmstadt (Allemagne) explique en détail comment sont implémentées ces contres-mesures et montre que dans certains cas l'attaque reste possible. Enfin, elle apporte ses propres contre-mesures.\\
			
			On peut noter que plusieurs librairies sont vulnérables à une attaque de Manger qui consiste à contrôler la taille des paramètres à haché, mais que l'implantation de RSA-OAEP d'OpenSSL ne le permet pas.La raison est que le décodage OAEP est linéaire quelque soit la taille des paramètres et les erreurs survenues. 	Il semble également y avoir un problème avec l'OAEP\_padding sur le chiffrement RSA. Bill Nickless recommande l'utilisation de PKCS\_padding. \cite{sourceforgeRSAbroken}	\\
		
		
		\subsubsection{Implémentation}
			
			\paragraph{Configuration visée.\\}
			
			L'étude a été réalisée sur la librairie OpenSSL-1.0.0.
			
			\paragraph{Fonction.\\}
			
			La fonction auditée se nomme RSA\_padding\_check\_PKCS1\_OAEP() et est accessible à partir du chemin \texttt{openssl/crypto/rsa/rsa\_oaep.c}.
		
		
			\begin{lstlisting}[style=customc,caption=rsa\_oaep.c,
			label=rsaoaep]
				lzero = num - flen;
				if (lzero < 0)
				{
					/* signalling this error immediately after detection might allow
					* for side-channel attacks (e.g. timing if 'plen' is huge
					* -- cf. James H. Manger, "A Chosen Ciphertext Attack on RSA
	Optimal
					* Asymmetric Encryption Padding (OAEP) [...]", CRYPTO 2001),
					* so we use a 'bad' flag */
					bad = 1;
					lzero = 0;
					flen = num; /* don't overflow the memcpy to padded_from */
				}
			\end{lstlisting}
		
			Le développeur n'a pas considéré qu'il y avait un grand danger dans le code de contre-mesures.\\
			Pourtant l'étude confirme qu'il y a un décalage de temps possible, certes léger mais qui peut entraîner une attaque en "branch prediction" (qui peut se traduire en prédiction par dérivation).\\
			
		\subsubsection{Conclusion}
		
			Il n'y a pas vraiment de quoi s'alarmer, cette attaque est en pratique infaisable sur un serveur car il y a suffisamment de variations de délais (différences de CPU, opérations multi-tâches, connexions réseaux, etc...) pour éviter une attaque par timing. Cependant, sur des systèmes embarqués l'attaque peut être réalisable, et il serait plus prudent de pallier ce problème.
			
	\subsection{Audit 2 : Chiffrement SSLv3 ou TLS 1.0 en mode CBC}
		\subsubsection{Normes visées}
	
			A remplir.	
	
		\subsubsection{Description de la faille}
			
			En Septembre 2011, une attaque en man in the middle très efficace a vu le jour contre les protocoles SSLv3 et TLS 1.0. \cite{ekr2011beast} \cite{imperial2011beast} \cite{goodin2011beast} \cite{gallagher2011beast}. L'attaque est à clair choisi. Le but étant d'insérer des morceaux de texte clair grâce au navigateur dans la requête chiffrée avec ces protocoles, ceci afin de récupérer les cookies de session.\\
			
			La technique est basique, un individu enregistre plusieurs cookies de session auprès de divers sites officiels (banques, messageries, etc...). Puis, il clique malencontreusement sur du code Java malveillant (publicité, image, etc...). et l'attaque se déroule automatiquement. L'ensemble des cookies est envoyé au serveur malveillant qui n'a plus qu'à déchiffrer les clés de session.\\
			
			La cause viendrait du mode de chiffrement choisi : CBC. 	SSL/TLS est un protocole qui chiffre un canal de communication.	De ce fait il ne chiffre pas un fichier unique, mais une série d'enregistrements.	Il y a deux façons d'utiliser le mode CBC dans ce cas précis :
			\begin{itemize}
			\item Prendre chacun de ces enregistrements indépendamment des autres. Générer un nouveau vecteur d'initialisation à chaque fois.
			\item Traiter ces enregistrements comme un seul objet en les concaténant. Le vecteur d'initialisation est donc choisi aléatoirement pour le premier enregistrement et pour les autres, il aura pour valeur le dernier bloc de l'enregistrement précédent.\\
			
			\end{itemize}
			
			SSLv3 et TLS 1.0 utilisent ce deuxième choix, cela soulève un lourd problème de sécurité.	En 2004, Moeller \cite{moeller2004cbc} trouve une méthode pour exploiter ce mauvais choix afin de récupérer des morceaux de textes clairs. Il y a certes une faille immense, mais peu exploitable. Les grandes entreprises savent (normalement) qu'il ne faut pas utiliser le mode CBC pour du chiffrement SSL/TLS. Et, dans tout les cas, plusieurs navigateurs ne permettent pas ce type d'attaque (c'est le cas de Chrome par exemple).
			
		\subsubsection{Tests}
			
			Nous n'avons pas repris les tests du logiciel BEAST qui s'avère être introuvable sur le Web (celui-ci étant un projet universitaire, développé par un étudiant de l'Université de Versailles). Mais une vidéo de l'exploit est accessible sur YouTube au lien ci-dessous : \\
			
			\textbf{Lien YouTube : } \href{http://www.youtube.com/watch?v=ujz4SXzWK9o} {http://www.youtube.com/watch?v=ujz4SXzWK9o}
		
		\subsubsection{Recommandations}

			La faille existe tant que l'association de ces protocoles avec le mode de chiffrement CBC existe. Même si l'attaque est infaisable sur les navigateurs les plus répandus (Chrome, Firefox, IE, Safari, ...), OpenSSL devrait pouvoir interdire cette association, et ne pas laisser le travail aux navigateurs. 	Mais rien n'empêche l'utilisation de ce chiffrement par un navigateur plus léger, nous pourrons tester cette vulnérabilité lors de notre partie 3 si nous trouvons un navigateur acceptant ce type de chiffrement.				
			
	\subsection{Audit 3 : Non-validation des certificats SSL}
		\subsubsection{Normes visées}
	
			A remplir.

		\subsubsection{Description de la faille}
		
			Six chercheurs des universités de Stanford et d'Austin au Texas, analyse une attaque en Man in the Middle autour des certificats SSL sans utilisation d'un navigateur. Le titre est sans appel "Le code le plus dangereux du monde" \cite{validate2012martin}.\\
			
			
			SSL doit permettre d'être sécurisé en toutes circonstances, que le cache DNS soit empoisonné, que les attaquants contrôlent les points d'accès et les routeurs, etc. . Il assure théoriquement trois grands principes de la cryptologie : la confidentialité, l'intégrité et l'authentification. Nous connaissons certaines failles au niveau du navigateur et de l'implantation SSL (voir ci-dessus). Mais il existe également d'autres cas d'utilisation du protocole SSL. Par exemple:
			\begin{itemize}
			\item Administration à distance basé sur le cloud, stockage sécurisé sur le cloud en local.
			\item Transmissions de données sensibles (ex: e-commerce)
			\item Services en ligne comme les messageries électroniques
			\item Authentification via applications mobiles comme Android et iOS\\
			\end{itemize}
			
			L'étude montre que la validation des certificats SSL est casée sur plusieurs applications et librairies dont :
			\begin{itemize}
			\item OpenSSL
			\item JSSE
			\item CryptoAPI
			\item NSS
			\item GnuTLS
			\item etc...\\
			\end{itemize} 
			
			En fait, un attaquant en Man In The Middle peut intercepter le secret entre un client et un serveur utilisant une connexion SSL. Il peut ainsi  récupérer des numéros de carte bancaire, avoir accès à une messagerie, récupérer des mots de passes, etc... La cause principale vient du fait que les développeurs retouchent les librairies cryptographiques à leur façon. En voulant réparer un bug ou en souhaitant rendre SSL compatible avec leurs API, ils injectent de nouvelles vulnérabilités. 	De plus, l'application est souvent propriétaire et payante ce qui rend le déboggage difficile.\\
			
			
			Que ce soit accidentel ou intentionnel, l'une des conséquences les plus graves est la non-validation de certificat sur des contexte où la sécurité est primordiale (e.g. payement en ligne). La faute ne revient pas directement au code d'OpenSSL, mais à une mauvaise utilisation des différentes fonctions et options.\\
			
			
			Voici quelques exemples concrets concernant différentes API : 
			\begin{itemize}
			\item Les services comme Amazon's Flexible Payments Service PHP et PayPal Payments Standard PHP passent le paramètre \texttt{CURLOPT\_SSL\_VERIFYHOST} à true alors que la valeur doit être passée à 2. La conséquence est la désactivation de la validation du certificat
			\item Lynx, un navigateur textuel très connu et souvent utilisé dans le développement d'applications, vérifie les certificats auto-signés seulement si la fonction de validation de certificat GnuTLS retourne une valeur négative. Malheureusement, dans certains cas la fonction peut retourner 0 pour certaines erreurs (dont les certificats signés par une autorité sans confiance).
			\item La librairie SSLSocketFactory de JSSE, très réputée, ne fait pas de vérification si la cypher suite du client vaut NULL ou est une chaîne vide.
			\item Vulnérabilités sur Apache HttpClient, WebSockets, Android, ...
			\item Autres causes célèbres : non reconnaissance des expressions régulières, non vérification du résultat de la validation, désactivation de l'authentification.\\
			\end{itemize}
			
					
		\subsubsection{Difficultés du code OpenSSL}
			

			OpenSSL ne déroge pas à la règle.\\
			Voici quelques vulnérabilités du code :
			\begin{itemize}
			\item Les contraintes de nom x509 ne sont pas correctement validés.
			\item Les applications DOIVENT fournir elles même leur code de vérification de nom d'hôte. Or, des protocoles comme HTTPS, LDAP ont chacun leurs propres notions de validations. Ainsi, Apache Libcloud utilise les librairie Python eux-même utilisant des commandes OpenSSL. Et sa méthode de vérification du nom d'hôte comporte des vulnérabilités pouvant causer des attaques en man in the middle (e.g "google.com" et "oogle.com" vérifie la même expression régulière)
			\item Un programme utilisant OpenSSL peut exécuter la fonction \texttt{SSL\_connect} pour le handshake SSL. Bien que certaines erreurs de validation soient signalées par \texttt{SSL\_connect}, d'autres ne peuvent être vérifier qu'en appelant la fonction \texttt{SSL\_get\_verify\_result}, alors que \texttt{SSL\_connect} se contente de retourner "OK".
			\end{itemize}

		\subsubsection{Exemple : Trillian}

			Trillian est une messagerie cliente instantanée	reliée à OpenSSL pour la sécurisation de l'établissement de connexion. Par défaut OpenSSL ne soulève pas d'exception en cas de certificat auto-signé ou de non-confiance auprès de la chaîne de vérification. A la place, il envoie un drapeau. De plus, il ne vérifie jamais le nom d'hôte.	Si l'application appelle la fonction \texttt{SSL\_CTX\_set} pour initialiser le drapeau \texttt{SSL\_VERIFY\_PEER}, alors \texttt{SSL\_connect} se ferme et affiche un message d'erreur lorsque le certificat n'est pas valide.	Mais Trillian n'initialise jamais ce drapeau.	Par conséquent, \texttt{SSL\_connect} va retourner 1 et le statut de la validation du certificat peut être connu en appelant la fonction \texttt{SSL\_get\_verify\_result}.	Encore une fois, Trillian n'appelle pas cette fonction.	Les conséquences sont très lourdes : vols de mots de passes, compromissions de services, révélations des paramètres de sécurité, etc...\\
			

			L'étude montre que l'attaque est possible sur la version 5.1.0.19 et antérieure de Trillian.

		\subsubsection{Conclusion}

			Les chercheurs nous donnent alors plusieurs leçons à retenir, dont voici quelques points :
			\begin{itemize}
			\item Premièrement, les vulnérabilités doivent être trouvées et réparées lors des phases de tests. Certaines se trouvent très facilement si les procédures de tests sont bien réalisées. 
			\item Deuxièmement, la plupart des librairies SSL ne sont pas \textbf{sûres par défaut}, laissant le choix de la sécurité aux applications de plus haut niveau avec choix des options, choix de la vérification de l'hôte, choix d'interprétation des résultats.
			\item Troisièmement, même les librairies SSL sûrs par défaut peuvent être mal utilisées par des développeurs changeant les paramètres par défaut par des paramètres non sécurisés. La cause peut venir d'une \textbf{mauvaise documentation} ou d'une mauvaise formalisation de la part de l'API. Les API devraient entre autre proposer des abstractions de haut niveau pour les développeurs comme des tunnels d'authentification, plutôt que de les laisser traiter des détails de bas niveau comme la vérification du nom d'hôte.\\
			\end{itemize}

			Nous conseillons surtout une meilleure documentation d'OpenSSL, et des rapports d'erreurs d'interfaces plus simples et plus consistants afin d'éviter les erreurs d'interprétation. L'idée des chercheurs de proposer des abstractions de haut niveau pour les applications semblent être une très bonne idée.
		
		


\section{Recommandations générales}




%Si nécessaire, Code de figure : 
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.2]{images/logo_univ.png}
	\caption{Titre de figure 2.1}
	\label{fig21}
\end{figure}