\chapter{Génération des clés}

\section{Définitions et contexte}
\subsection{Clés cryptographiques}

La génération de clé est une notion fondamentale de cryptographie. En effet, les données sont protégées grâce à des algorithmes (ou des méthodes cryptographiques) et des clés cryptographiques. Les clés cryptographiques sont notamment utilisées pour le chiffrement et le déchiffrement de données. 
Relativement aux deux types de cryptographies, on compte deux types de clés : 
\begin{itemize}
\item les clés symétriques pour les chiffrements symétriques;
\item les clés les clés publiques/privées pour le chiffrement asymétriques.\\
\end{itemize}

On se considérera dans ce chapitre dans un milieu optimal : 
\begin{enumerate}
\item L'algorithme cryptographique considéré est optimal
\item La génération de bits aléatoire est optimale
\end{enumerate}


\subsubsection{Clés d'algorithmes symétriques}
Les algorithmes symétriques utilisent pour leur chiffrement une clé symétrique qui est partagée par chacun des correspondant. 

\begin{figure}[H]
\begin{center}
\begin{tikzpicture}[node distance=2cm]
\node 	(titre) 		[] 		{\textbf{Echange de message par chiffrement symétrique}};
\node 	(k1) 	[below of=titre,xshift=-3cm,yshift=1cm] {k};
\node 	(k2) 	[right of=k1,xshift=5cm] {k};
\node 	(E) 		[processS,below of=k1] {E (Alice)};
\node 	(D) 		[processS,below of=k2] {D (Bob)};
\node 	(m1)		[left of=E] {m};
\node 	(m2)		[right of=D] {m};
\begin{pgfonlayer}{background}
\node[punkt, fit=(titre)(E)(D)(k1)(k2)(m1)(m2), fill=yellow!5] (groupclient) {};
\end{pgfonlayer}


\draw	[arrow]	(k1) -- (E);
\draw	[arrow]	(k2) -- (D);
\draw	[arrow]	(D) -- (m2);
\draw	[arrow]	(m1) -- (E);
\draw	[arrow]	(E) -- node[anchor=north] {$E_k(m)=c$} (D);
\end{tikzpicture}
\end{center}
\caption{Chiffrement symétrique - Alice envoie un message $c$ chiffré à Bob qui le déchiffre}
\label{sym}
\end{figure}






\subsubsection{Clés d'algorithmes asymétriques}

Les clés d'algorithmes symétriques sont de deux catégories, les clés privées et les clés publiques. Les clés publiques sont disponibles pour tous, par demande à l'utilisateur, ou bien souvent par certificat. 

\begin{figure}[H]
\begin{center}
\begin{tikzpicture}[node distance=2cm]
\node 	(titre) 		[] 		{\textbf{Echange de message par chiffrement asymétrique}};
\node 	(k1) 	[below of=titre,xshift=-3cm,yshift=1cm] {};
\node 	(k2) 	[right of=k1,xshift=5cm] {$k_B'$};
\node 	(E) 		[processS,below of=k1] {E (Alice)};
\node 	(D) 		[processS,below of=k2] {D (Bob)};
\node 	(m1)		[left of=E] {m};
\node 	(m2)		[right of=D] {m};
\node 	(key1) 	[below of=E] {$k_A$ (publique), $k_A'$ (privée)};
\node 	(key2) 	[below of=D] {$k_B$ (publique), $k_B'$ (privée)};

\begin{pgfonlayer}{background}
\node[punkt, fit=(titre)(E)(D)(k1)(k2)(m1)(m2)(key1)(key2), fill=yellow!5] (groupclient) {};
\end{pgfonlayer}


\draw	[arrow]	(k2) -- (D);
\draw	[arrow]	(D) -- (m2);
\draw	[arrow]	(m1) -- (E);
\draw	[arrow]	(E) --  node[anchor=north] {$E_{k_B}(m)=c$} (D);

\end{tikzpicture}
\end{center}
\caption{Chiffrement asymétrique - Alice envoie un message $c$ chiffré à Bob avec sa clé publique qui le déchiffre}
\label{asym}
\end{figure}

Comme montré en figure \ref{asym}, Alice chiffre avec la clé publique de Bob un message, qui lui-même déchiffre le message avec la clé privée.

\subsection{Méthode de génération et sécurité}


Les systèmes utilisent des entiers comme clé. Les clés sont générées en utilisant des générateurs de nombres aléatoires (RNG) ou des générateurs de nombres pseudo aléatoires (PRNG). 

\subsubsection{Génération de clés quelconques}
Un générateur de bits aléatoires (RGB) approuvé est utilisé pour générer la clé cryptographique. Le RGB doit fournir une entropie complète ou suffisante aux exigences de sécurité du système. Les RGB peuvent  permettre de générer complètement et "directement" la clé. C'est le cas pour les  les clés privées des algorithmes AES ou DSA.
Les RGB peuvent aussi être utilisés comme \textit{seed} pour générer des clés, suivants des critères spécifiques. C'est le cas pour RSA, où habituellement le \textit{seed} est utilisé comme point de départ pour trouver un nombre premier suivant les critères du FIPS 186-3 \cite{fips186-3}.

\subsubsection{Génération de paires de clés asymétriques}
Les algorithmes asymétriques demandent la création de paires de clés asymétriques (privée/publique), dont chaque clé est est associée avec une seule entité, le possesseur de la clé. Les clés sont généralement générées par le possesseur direct de la clé, ou par une autorité de confiance qui fournit la clé au possesseur de façon sûre.
Il convient au moment de la génération de bien considérer les paramètres deux paramètres principaux : 
\begin{enumerate}
\item l'espace de clés, qui doit être suffisamment grand pour éviter les doublons et les cycles.
\item Générer les premiers de façon la plus aléatoire possible. Ceci nécessite un bon choix de stratégie d'identification de premiers. On peut par exemple utiliser des algorithmes permettant de détecter le prochain premier suivant un entier tiré aléatoirement. 
\end{enumerate}


\section{Audits}
	\subsection{Audit 1 : Le générateur de Diffie-Hellman}
		\subsubsection{Normes visées}

		Voici l'algorithme de génération de g, d'après la RFC 2631 \cite{rfc2631} datant de 1999 et dérivé de la FIPS-186 : 
		\begin{itemize}
		\item 1- Soit $j = (p - 1)/q$.
		\item 2- Choisir $h \in \mathbb{N}$, tel que $1 < h < p - 1$
		\item 3- Calculer $g = h^j \mod p$
		\item 4- Si $g = 1$ recommencer l'étape 2\\
		\end{itemize}
	
		Mais depuis 2006, on peut lire comme recommandation dans la RFC 4419 (pour une utilisation SSH) : "It is recommended to use 2 as generator, because it improves	efficiency in multiplication performance.  It is usable even when itis not a primitive root, as it still covers half of the space of possible residues."\\
	
		\subsubsection{Faille}
	
		Lorsque nous avons étudié le code de Diffie-Hellman dans OpenSSL, nous nous	sommes penchés sur un choix plutôt étrange. La valeur du générateur est toujours fixé à 2 ou à 5. \\
	
		Le générateur de Diffie-Hellman n'étant pas une racine primitive dans $\mathbb{Z}/\mathbb{Z}_p$, les conséquences sont :
		\begin{itemize}
		\item L'espace des clés possibles est fortement réduit (Si $g=2 \implies$ espace divisé par deux)
		\item Deux clés privées distinctes pourront avoir une clé publique commune
		\item La méthode de cryptanalyse Baby-step Giant-step peut s'en trouver 
		facilité.\\
		\end{itemize}
	
		Évidemment, ce choix n'est pas une faille en soit, il n'est juste pas optimal et résulte d'un bon compromis entre vitesse et sécurité. Pour une sécurité optimale, il est conseillé de choisir un générateur qui soit une racine primitive, pour être certain que personne ne puisse signer, déchiffrer des messages à votre place!\\
	
	
		\subsubsection{Implémentation}
		
		\paragraph{Configuration visée.\\}

		La version actuelle d'OpenSSL : 1.1.0
		
		\paragraph{Fonction.\\}
		La fonction liée à cette norme est accessible sous le paquetage \texttt{openssl/crypto/dh/dh\_gen.c} (cf. \textit{Listing} \ref{dhgen}). Les commentaires sont très intéressant pour comprendre le choix du générateur par l'équipe de développement.
		
		
		\begin{lstlisting}[style=customc,caption=dh\_gen.c, label=dhgen]
			if (generator <= 1)
			{
				DHerr(DH_F_DH_BUILTIN_GENPARAMS, DH_R_BAD_GENERATOR);
				goto err;
			}
			if (generator == DH_GENERATOR_2)
			{
				if (!BN_set_word(t1,24)) goto err;
				if (!BN_set_word(t2,11)) goto err;
				g=2;
			}
			#if 0 /* does not work for safe primes */
				else if (generator == DH_GENERATOR_3)
				{
					if (!BN_set_word(t1,12)) goto err;
					if (!BN_set_word(t2,5)) goto err;
					g=3;
				}
			#endif
			else if (generator == DH_GENERATOR_5)
			{
				if (!BN_set_word(t1,10)) goto err;
				if (!BN_set_word(t2,3)) goto err;
				/* BN_set_word(t3,7); just have to miss
				 * out on these ones :-( */
				g=5;
			}
			else
			{
				/* in the general case, don't worry if 'generator' is a
				 * generator or not: since we are using safe primes,
				 * it will generate either an order-q or an order-2q group,
				 * which both is OK */
				if (!BN_set_word(t1,2)) goto err;
				if (!BN_set_word(t2,1)) goto err;
				g=generator;
			}
		\end{lstlisting}
		
		\subsubsection{Conclusion}

		Ainsi selon la norme RFC-4419, le choix du générateur peut se résumer à un petit générateur qui ne serait pas une racine primitive. La criticité du risque est très grande, car si deux personnes possèdent la même clé publique pour deux clés privées distinctes, ils pourront alors déchiffrer les messages, et signer à la place de l'autre. Mais, la probabilité d'une telle collision est quasiment nulle, il est simplement deux fois plus efficace de générer deux clés privées possédant la même clé publique, que de retrouver la clé privée en brute force.
		OpenSSL laisse en plus le choix au développeur de choisir une racine primitive comme générateur, pour des cas d'extrême sécurité.
		
	\subsection{Audit 2 : Diffie-Hellman Ephémère en mode FIPS}
		\subsubsection{Normes visées}


		\subsubsection{Description de la faille}
	
		Une faille plus grave concerne le mode FIPS (Federal Information Processing Standard) d'OpenSSL, qui peut être compilé avec la commande \texttt{./config fipscanisterbuild}". En effet, un attaquant situé entre le client et le serveur connaissant la clé secrète du serveur peut déchiffrer une session SSL/TLS. \\
	
		L'algorithme EDH/DHE (Diffie-Hellman Ephémère) permet de calculer une nouvelle clé connue uniquement du client et du serveur, donc l'attaquant intermédiaire ne peut plus déchiffrer la session. Cependant, en mode FIPS, OpenSSL ne rejette pas les paramètres P/Q faibles pour EDH/DHE. Lorsque OpenSSL est compilé en mode FIPS, un attaquant en Man-in-the-middle peut donc forcer la génération d'un secret Diffie Hellman prédictible, en modifiant par exemple le traffic réseau. \cite{vigilance-vul-10585} \cite{CVE-2011-5095}.

		La faille en elle même n'est pas suffisante pour faire l'attaque, il requiert également une implémentation SSL faible. 
	
		\subsubsection{Implémentation}
		
			\paragraph{Configuration visée.\\}
		
			La version vulnérable d'OpenSSL est la 0.9.8, en mode FIPS uniquement.

			\paragraph{Fonction.\\}

			La fonction est accessible au chemin \texttt{openssl/crypto/dh/dh\_key.c}. La figure \textit{Listing} \ref{dhkey} montre le diff entre les deux versions.

			\begin{lstlisting}[language=diff,caption=dh\_key.c, label=dhkey]
			-------------------------------- dh/dh_key.c --------------------------------
			-	if (!DH_check_pub_key(dh, pub_key, &check_result) || check_result)
			-	{
			-		DHerr(DH_F_COMPUTE_KEY,DH_R_INVALID_PUBKEY);
			-		goto err;
			-	}
			\end{lstlisting}

			Cette partie causait un faux positif sous certaines conditions pouvant fragiliser le système.

			\paragraph{Solution logicielle.\\}

			Nessus Vulnerability Scanner est un logiciel permettant de tester la configuration du serveur afin d'identifier entre autres de problèmes d'authentification \cite{nessus}. Le système RedHat préconise son utilisation pour savoir si cette vulnérabilité concerne notre système.
		
	\subsubsection{Conclusion}

		Il est tout d'abord recommandé de passer à la version OpenSSL supérieur, sinon de désactiver le mode FIPS, ou encore de configurer la ciphersuite afin de ne pas permettre au serveur d'utiliser DH comme algorithme d'échange de clés.



\section{Recommandations générales}
