\chapter{Entropie}
\section{Définitions et contexte}

\subsection{Introduction}
Cette partie explicite les notions d'entropie nécessaires pour la définition d'aléatoire de certains programmes, mais décrit aussi les sources qui de génération de bits aléatoires et les tests liés. \\



Trois axes principaux sont nécessaires à la mise en place d'un générateur cryptographique aléatoire de bits  : 
\begin{itemize}
\item Une source de bits aléatoires (source d'entropie)
\item Un algorithme pour accumuler ces bits reçus et les faire suivre vers l'application en nécessitant.
\item Une méthode appropriée pour combiner ces deux premiers composants\\
\end{itemize}


\subsection{Estimation de l'entropie générée par la source}
Il est tout d'abord important de vérifier que la source d'entropie choisie produit suffisamment d'entropie, à un taux égalant voire dépassant une borne fixée. Pour ce faire, il faut définir avec précision la quantité d'entropie générée par la source. Il est de plus important de considérer les différents comportements des composants de la source, afin d'éliminer les interactions qu'ils peut y avoir entre les composants. En effet, ceci peut provoquer une redondance dans la génération d'entropie si cela n'est pas considéré. Étant donné une source biaisée, l'entropie générée sera conditionnée et donc plus facilement prévisible/estimable.

La source d'entropie doit donc être minutieusement choisie, sans qu'aucune interaction et conditionnement ne soit possible.

\subsection{Concept d'entropie}
\paragraph{Définition.\\}
Soit $X$ est une V.A. discrète. On définit l'\textbf{entropie} de $X$ comme suit : 
$$H(X) = - \sum_x P(X=x)*log(P(X=x))	 $$ 
Le logarithme est dans notre cas de base 2. L'entropie se mesure en shannons ou en bits.\\

\paragraph{Définition.\\}
On définit le \textbf{désordre} (ou incertitude) étant liée à cette expérience aléatoire. Si l'on considère l'ensemble fini des issues possibles d'une expérience $\lbrace v_1,...,v_n \rbrace$, l'entropie de l'expérience vaudra :
$$H(\epsilon) = - \sum_x P(\lbrace a_i \rbrace)*log(P(\lbrace a_i \rbrace))	 $$ 

\paragraph{Propriété.\\} 
On constate que l'entropie est maximale lorsque X est équi-répartie. En effet, si l'on considère n éléments de X étant équi-répartie, on retrouve notre entropie de $H(X) = log(n)$. \\


Ainsi, on comprend qu'une variable aléatoire apporte en moyenne un maximum d'entropie lorsqu'elle peut prendre chaque valeur avec une équiprobabilité. D'un point de vue moins théorique, on considère que plus l'entropie sera grande, plus il sera difficile de prévoir la valeur que l'on observe.

\paragraph{Min-entropy.\\}
La recommandation du NIST propose le calcul de \textit{Min-entropy} pour mesurer au pire des cas l'entropie d'une observation. \\

Soit $x_i$ un bruit de la source d'entropie. Soit $p(x_i)$ la probabilité d'obtenir $x_i$. On définit l'entropie au pire des cas telle que : 
$$\text{Min-entropy}=-log_2(max(p(x_i))$$
La probabilité d'observer $x_i$ sera donc au minimum  $\frac{1}{2^\text{Min-entropy}}$.

\subsection{Source d'entropie}
\paragraph{Approche théorique.\\}
La source d'entropie est composée de 3 éléments principaux : 
\begin{itemize}
\item le \textbf{bruit source}, qui est la voûte de la sécurité du système. Ce bruit doit être non déterministe, il renvoie de façon aléatoire des bits grâce à des processus non déterministes. Le bruit ne vient pas nécessairement directement d'éléments binaires. Si ce bruit est externe, il est alors converti en données binaires. La taille des données binaires générées est fixée, de telle sorte que la sortie du bruit source soit déterminé dans un espace fixe.
\item le \textbf{composant de conditionnement}, qui permet d'augmenter ou diminuer le taux d'entropie reçu. L'algorithme de conditionnement doit être un algorithme cryptographique approuvé.
\item une \textbf{batterie de tests}, partie également intégrante du système. Des tests sont réalisés pour déterminer l'état de santé du générateur aléatoire, permettant de s'assurer que la source d'entropie fonctionne comme attendu. On considère 3 catégories de tests : 
	\begin{itemize}
	\item Les tests au démarrage sur tous les composants de la source
	\item Les tests lancés de façon continue sur le bruit généré par la source
	\item Les tests sur demande (qui peuvent prendre du temps)
	\end{itemize}
	L'objectif principal de ces tests est d'être capable d'identifier rapidement des échecs de génération d'entropie, ceci avec une forte probabilité. Il est donc important de déterminer une bonne stratégie de détermination d'échec pour chacun de ces tests.\\
\end{itemize}

\begin{figure}[H]
\begin{center}
\begin{tikzpicture}[node distance=2cm]
\node (source) {\textbf{Source d'entropie}};
\node (bruit) [below of=source,yshift=1cm,xshift=0.5cm] {\textbf{Bruit}};
\node (donnees) [io,below of=bruit,yshift=1cm,xshift=0.5cm,pattern=dots,pattern color=orange] {Données};
\node (digit) [process, right of=donnees, xshift=4cm] {Digitalisation};
\node (cond) [process, below of=digit,text width=3cm,yshift=-0.5cm] {Conditionnement (optionnel)};
\node (bat) [process, right of=cond, xshift=4cm] {Batterie de tests}; 
\node (dec) [decision, below of=cond,yshift=-0.5cm] {Sortie}; 
\node (appli) [process, below of=dec, yshift=-1cm] {Application};

\begin{pgfonlayer}{background}
\node[punkt, fit=(donnees)(digit)(cond)(bat)(dec)(bruit)(source), fill=yellow!5] (groupclient) {};
\end{pgfonlayer}

\begin{pgfonlayer}{background}
\node[punkt, fit=(donnees)(digit)(bruit), fill=yellow!20] (groupclient) {};
\end{pgfonlayer}

\draw [arrow] (donnees) -- (digit);
\draw [arrow] (digit) -- node[anchor=east] {out1}(cond);
\draw [arrow] (cond) --  node[anchor=east] {out2} (dec);
\draw [arrow] (digit) -| node[anchor=south] {out1} (bat);
\draw [arrow] (cond) -- node[anchor=south] {out2} (bat);
\draw [arrow] (bat) |- node[anchor=north] {true/false} (dec);
\draw [arrow] (dec) -- node[anchor=east] {output/error}  (appli);
\end{tikzpicture}
\end{center}
\caption{Composants d'une source d'entropie. \texttt{out1} est une chaîne binaire de taille quelconque et \texttt{out2} est une chaîne binaire conditionnée de taille fixe. }
\end{figure}

\paragraph{Modèle conceptuel.\\}
Suivant ces sections précédentes, on peut déterminer 3 interfaces conceptuelle :
\begin{itemize}
\item \texttt{getEntropy} qui retourne 
	\begin{itemize}
	\item \texttt{entropy\_bitstring}, une chaîne de bits de l'entropie demandée
	\item \texttt{assessed\_entropy}, entier indiquant le nombre de bits d'entropie de \texttt{entropy\_bitstring}
	\item \texttt{status}, booléen renvoyant \texttt{true} si la requête est satisfaite, \texttt{false} sinon.\\
	\end{itemize}
\item \texttt{getNoise}	 qui prend en entrée : 
	\begin{itemize}
	\item \texttt{number\_of\_sample\_requested}, entier indiquant le nombre d'éléments demandés en retour à la source de bruit
	\end{itemize}
et en sortie : 
	\begin{itemize}
	\item \texttt{noise\_source\_data}, la séquences d'éléments demandée, ayant la taille \texttt{number\_of\_sample\_requested}.
	\item \texttt{status}, booléen renvoyant \texttt{true} si la requête est satisfaite, \texttt{false} sinon.\\
	\end{itemize}
\item \texttt{HealthTest}, élément test de la batterie de tests, qui prend en entrée :
	\begin{itemize}
	\item \texttt{type\_of\_test\_requested}, chaine de bits déterminant le type de tests que l'on souhaite effectuer (peut différer suivant le type de source)
	\end{itemize}
et en sortie : 
	\begin{itemize}
	\item \texttt{pass-fail\_flag}, booléen qui renvoie \texttt{true} si la source d'entropie a réussi le test, \texttt{faux} sinon.
	\end{itemize}	
\end{itemize}


\subsection{Forces et faiblesses des différents PRNG}

	Nos machines utilise ce qu'on appel des PRNG (Pseudo Random Number Generator), 
	ce sont des algorithmes qui génèrent une séquence de nombre s'apparentant
	à de l'aléatoire. En réalité rien est aléatoire car tout est déterminé par
	des valeurs initiales (État du PRNG) et des contextes d'utilisation.\\
	
	Un bon PRNG se doit d'avoir une très forte entropie (proche de un), afin
	d'éviter de délivrer de l'information.

	Comme l'entropie est fourni majoritairement (si ce n'est totalement) par 
	l'OS, il est donc nécessaire de détailler les PRNG les plus utilisés
	(Surtout par les systèmes Linux et BSD - qui sont les ceux qui générent le
	plus de certificats SSL).\\

	Nous nous basons sur la RFC 4086 \cite{rfc4086}: 
	Randomness requirements for security
	pour le choix des PRNG selon les différents	systèmes.

	\subsubsection{/dev/urandom et /dev/random sous Linux}
	
		Sous Linux, un pool est initialisé avec 512 octets, auquel on ajoute
		le temps émis par un évènement et son état parmis : 
		\begin{itemize}
			\item Les interruptions clavier - heure et code d'interruption
			\item Les interruptions de disques - heure de lecture ou écriture
			\item Les mouvements de souris - heure et position\\
		\end{itemize}
	
		Quand des octets aléatoires sont demandés, la pool est haché avec SHA-1 
		(20 octets). S’il est demandé plus que 20 octets, le haché est mélangé 
		dans la pool pour rehacher la pool ensuite etc. À chaque fois que l’on 
		prend des octets dans la pool, l’entropie estimée est décrémentée.\\

		Pour assurer un niveau minimum d’entropie au démarrage, la pool est 
		écrite dans un fichier à l’extinction de la machine.\\

		/dev/urandom fonctionne selon le même principe sauf qu’il n’attend pas 
		qu’il y ait assez d’entropie pour donner de l’aléatoire. Il convient 
		pour une génération de clefs de session.\\

		Pour générer des clefs cryptographiques de longue durée, il est 
		recommandé d’utiliser /dev/random pour assurer un niveau minimum 
		d’entropie.\\
		
		En effet, sur un serveur sans souris ni clavier, définir l'entropie avec
		/dev/urandom est très risqué. On recommande donc l'utilisation de 
		/dev/random lors de l'audit OpenSSL sur les versions Linux.\\

		/dev/random utilise une pool d’entropie de 4096 bits (512 octets) génère 
		de l’aléa et s’arrête lorsqu’il n’y a plus assez d’entropie et attend 
		que la pool se remplisse à nouveau.\\
		
		Si vous souhaitez connaître l'entropie disponible, la commande est : \\
		cat /proc/sys/kernel/random/entropy\_avail\\

		Désormais, la taille de la pool est hardcodée dans le noyau Linux 
		(/drivers/char/random.c:275)\\
		
		Linux offre également la possibilité de récupérer de l’aléa depuis un 
		RNG matériel avec la fonction get\_random\_bytes\_arch
		\cite{archlinuxRNG}\\
	
		Un patch est également disponible afin de générer de l'aléa avec un 
		débit de 100kB/s \cite{mueller2013rng}. 
		L'entropie est récupérée par le CPU timing jitter.\\
		
		En conclusion, /dev/random doit être utilisé pour une haute qualité
		d'entropie (i.e. haute sécurité de chiffrement, one-time pad).\\
		Tandis que /dev/urandom doit être utilisé pour des applications non
		sensibles à des attaques cryptographiques (i.e. jeu en temps réel),
		car elle génère plus d'entropie que /dev/random sur un temps donné, 
		mais s'arrêtera même si il n'a pas récolté suffisamment d'entropie. 
	

	\subsection{/dev/random sous FreeBSD et /dev/arandom sous OpenBSD}
	
		Il faut faire attention au faux ami, le /dev/random du FreeBSD n'est pas 
		le même que celui de Linux.
		En fait, il est semblable au /dev/urandom de Linux, et est donc tout 
		autant proscrit lors de notre audit.\\
		
		Même principe avec le /dev/arandom de OpenBSD, qui a également une 
		entropie faible pour du chiffrement cryptographique sûr. Il se base
		en fait sur un algorithme modifié du RC4 nommé ARC4 (Alleged RC4) pour 
		générer des données aléatoires.\\
		Pour rappel, RC4 était un projet commercial de la RSA Security, et un 
		hacker anonyme a publié un code identique, devenu légitime, identifié par
		ARC4.\\
		De nos jours, il est fortement conseillé de ne plus utiliser RC4 car le 
		flux de données aléatoire n’est pas vraiment aléatoire et il existe des 
		attaques qui prédisent la sortie de l’algorithme (Attaque de Fluhrer, 
		Mantin et Shamir) \cite{fmsrc42009}.\\
		Sur plusieurs de nos sources (plus anciennes), il est recommandé
		d'utiliser /dev/arandom pour sa rapidité (71 Mb/s) et sa bonne source
		d'entropie. Ce n'est plus vraiment le cas aujourd'hui.\\
		
		
		
	
	\subsection{CryptGenRandom sous Windows}
	
		Du coté de Microsoft, il recommande aux utilisateurs de Windows 
		d’utiliser CryptGenRandom, qui est un appel système de génération d’un 
		nombre pseudo-aléatoire. La génération est réalisée par une librairie 
		cryptographique (Cryptographic service provider library). Celui ci gère 
		un pointeur vers un buffer en lui fournissant de l’entropie afin de 
		générer un nombre pseudo aléatoire en retour avec en plus, le nombre 
		d’octet d’aléatoire désiré.\\

		\lstset{language=Java}
		\begin{lstlisting}
		BOOL WINAPI CryptGenRandom(
			_In_     HCRYPTPROV hProv,
			_In_     DWORD dwLen,
			_Inout_  BYTE *pbBuffer
		);
		\end{lstlisting}
	
		Le service provider sauvegarde une variable d’état d’un sel pour chaque 
		utilisateur. Lorsque CryptGenRandom est appelé, celui ci est combiné 
		avec un nombre aléatoire généré par la librairie en plus de différentes 
		données systèmes et utilisateurs telles que : \\
		\begin{itemize}
		\item l’ID du processus
		\item l'ID du thread
		\item l'horloge système
		\item l'heure système
		\item l'état de la mémoire
		\item l’espace de disque disponible du cluster
		\item le haché du block d'environnement mémoire de l’utilisateur\\
		\end{itemize} 
		
		Le tout est envoyé à la fonction de hachage SHA-1 et le nombre en sortie 
		est utiliser comme sel pour une clef RC4. \\
		
		Cette clef est enfin utilisé pour produire des données pseudo aléatoire 
		et mettre à jour la variable d’état du sel de l’utilisateur. 

	
	
	\subsection{Autres systèmes}
	
		Nous avons également d'autres RNG comme srandom, prandom ou
		encore wrandom \cite{miros2013}\\
		
		/dev/srandom est simple et lent, il n'est pas recommandé de l'utilisé.\\
	
		Certains systèmes ne disposant pas de /dev/*random, il est alors possible
		d'utiliser l'EGD (Entropy Gathering Daemon) \cite{egdsf.net}.\\
		
		Il faut pour cela utiliser les fonctions OpenSSL RAND\_egd, 
		RAND\_egd\_bytes et RAND\_query\_egd\_bytes. \\
		
		L'EGD est également utilisé par GPG, et peut être utilisé comme seed.




\subsection{Standards}
\subsubsection{RFC 4086}
\subsubsubsection{Sous Linux}
Suivant la RFC 4086 \nocite{rfc4086} intitulée \textit{Randomness requirements for security} \nocite{rfc4086}, 
Il existe plusieurs niveaux de récupération d'aléatoire sous linux  :
\begin{itemize}
\item Point primaire (\textit{Primary pool}) :\\
512o (128 mots de 4o) + ajout d’entropie
\item Point secondaire (\textit{Secondary pool}) :\\
128o pour générer le fichier \texttt{/dev/random}. Un autre point secondaire existe : \texttt{/dev/urandom}\\
\end{itemize}

L'entropie est récupérée par exemple lorsqu'un événement apparaît (telle qu'une interruption du disque dur), la date et l'heure de l'événement est récupéré et XORée dans le \textit{pool}, puis  est "mélangée" avec une primitive polynomiale possédant un degré de 128. Le \textit{pool} devient ensuite une boucle où de nouvelles données sont XORées ("mélangées" encore par la primitive polynomiale) tout le long du \textit{pool}.\\


A chaque appel qui rajoute de l'entropie dans le \textit{pool}, celui-ci calcule une estimation de la probabilité d'une réelle entropie des données. Le pool contient alors l'accumulation des estimations de l'entropie totale contenue dans le pool.\\


Les sources d'entropie sont les suivantes :
\begin{itemize}
\item Interruption Clavier  
\item Interruption des complétions du disque
\item Mouvements de la souris
\end{itemize}

Quand des octets aléatoires sont demandés, la \textit{pool} est haché avec SHA-1 (20 octets). Si plus de 20 octets  est demandé plus que 20 octets, le haché est mélangé dans la pool pour rehacher la pool ensuite etc. À chaque fois que l’on prend des octets dans la pool, l’entropie estimée est décrémentée. Pour assurer un niveau minimum d'entropie au démarrage, la \textit{pool} est écrite dans un fichier à l'extinction de la machine.\\

\texttt{/dev/urandom} fonctionne selon le même principe sauf qu'il n'attend pas qu'il y ait assez d'entropie pour donner de l'aléatoire. Il convient pour une génération de clefs de session. Pour générer des clefs cryptographiques de longue durée, il est recommandé d'utiliser \texttt{/dev/random} pour assurer un niveau minimum d'entropie.\\

\subsubsubsection{Sous Windows}
Du coté de Microsoft, il est recommandé aux utilisateurs d'utiliser \texttt{CryptGenRandom}, qui est un appel système de génération d'un nombre pseudo-aléatoire. La génération est réalisée par une librairie cryptographique (\textit{Cryptographic service provider library}). Celle-ci gère un pointeur vers un \textit{buffer} en lui fournissant de l'entropie afin de générer un nombre pseudo aléatoire en retour avec en plus, le nombre d'octets d'aléatoires désirés.

\begin{verbatim}
BOOL WINAPI CryptGenRandom(
  _In_     HCRYPTPROV hProv,
  _In_     DWORD dwLen,
  _Inout_  BYTE *pbBuffer
);
\end{verbatim}


Le service \textit{provider} sauvegarde une variable d'état d'un sel pour chaque utilisateur. Lorsque \texttt{CryptGenRandom} est appelé, celui-ci est combiné avec un nombre aléatoire généré par la librairie en plus de différentes données systèmes mais aussi de l'utilisateur tels que l'ID du processus  du \textit{thread}, l'horloge système, l'heure système, l'état de la mémoire, l'espace de disque disponible du \textit{cluster} et le haché du block d'environnement mémoire de l'utilisateur. \\

Le tout est envoyé à la fonction de hachage SHA-1 et le nombre en sortie est utilisé comme sel de clef RC4.  Cette clef est enfin utilisée pour produire des données pseudo-aléatoires et mettre à jour la variable d'état du sel de l'utilisateur. 

\subsubsubsection{OpenBSD}
Dans OpenBSD, on trouve des sources d'aléatoire supplémentaires par rapport à Linux. On trouve notamment \texttt{/dev/arandom} qui génère de l'aléatoire selon une version leakée de RC4 : \texttt{ARC4} (Alleged RC4). Pour rappel, RC4 était un projet commercial de RSA Security et un hacker anonyme a publié un code qui faisait la même chose, code légitime identifié par ARC4. De nos jours, il est fortement conseillé de ne plus utiliser RC4 car le flux de données aléatoires n'est pas vraiment aléatoire et il existe des attaques qui prédisent la sortie de l'algorithme (Attaque de Fluhrer, Mantin et Shamir) \nocite{Fluhrer01weaknessesin}.



\section{Audits}
	\subsection{Audit 1 : Le cas Debian 4.0 et OpenSSL 0.9.8}
	\subsubsection{Norme visée}
	\subsubsection{Faille}
		\subsubsubsection{Description}
		Le 13 Mai 2008, Luciano Bello découvert une faille critique du 
		paquet d'OpenSSL sur les systèmes Debian
		\cite{faille2008linux.org}. Un mainteneur Debian 	
		souhaitant corriger quelques bugs aurait malencontreusement 	
		supprimé une grosse source d'entropie lors de la génération des 
		clés. \\
		Il ne restait plus que le PID comme source d'entropie!\\
		Comme celui-ci ne pouvait dépasser 32.768 (qui le PID maximal
		atteignable), l'espace des clés a été restreint à 264.148 clés
		distinctes.\\
		
		Analysons plus en détail cette faille. Elle se situe au niveau de 
		la fonction \textbf{md\_rand.c}.
		La ligne \textbf{MD\_Update(\&m, buf, j);} a été commentée.
		La conséquence est le blocage de la graine (seed) que l'on 
		passe ensuite au PRNG.\\
	
		Cette ligne a été commentée par erreur en voulant corriger un
		avertissement soulevé par le compilateur Valgrind sur une valeur
		non initialisé.\\
	
		Le 14 Mai 2008, Steinar H. Gunderson démontre simplement comment
		en connaissant le secret $k$ d'une signature, on peut retrouver
		la clé privée d'un certificat immédiatement \cite{gunderson2008}.\\
	
		Ce secret k étant généré avec un PRNG prévisible, on peut stocker
		deux signatures utilisant le même $k$, où le prédire directement.\\
	
		Une signature DSA consiste en deux nombres $r$ et $s$ tels que :\\
		$r = (g^k [p]) [q]$\\
		$s = (k^{-1} * (H(m) + x * r)) [q]$\\
	
		La clé publique = $(p, q, g)$.\\
		Le message en clair = $m$, et $H(m)$ est le fingerprint de $m$ connu.\\
	
		Attaque \no 1 : En connaissant $k$	\\
		$s * k [q] = (H(m) + x*r) [q]$\\
		$\iff (s * k - H(m)) [q] = x*r [q]$\\
		$\iff ((s*k - H(m))*r^{-1})[q] = x$\\
		$\iff (s*k - H(m))*r^{-1} = x$\\

		Attaque \no 2 : Deux messages possèdent le même $k$\\
		$s_1 = (k^{-1} (H(m_1) + x*r)) [q]$\\
		$s_2 = (k^{-1} (H(m_2) + x*r)) [q]$\\
		$\iff s_1 - s_2 = (k^{-1} (H(m_1) - H(m_2)) [q]$\\
		$\iff (s_1 - s_2)*(H(m_1) - H(m_2))^{-1} = k^{-1} [q]$\\
		$\iff$ On connaît $k \implies$ Attaque 1\\

		Pour savoir si une clé SSL, SSH, DNSSEC ou OpenVPN est affectée, 
		plusieurs détecteur de données \cite{dowkd.pl} 
		\cite{openssl-blacklist} de clés faibles sont 
		fournis par l'équipe Security de Debian, en même temps que
		l'avertissement de sécurité \cite{debian2008bug}.\\ 

		\subsubsubsection{Tests}

		Nous avons décidé de tester le nombre de certificats vulnérables 
		causés 	par le bug OpenSSL de Debian (qui reste le plus populaire), et
		connaissant la blacklist des clés privés. \\
	
		Les résultats nous montrent que sur 500.000 certificats récupérés, au moins
		\footnote{Le logiciel ne prend pas en compte les clés $\leq$ à 512 bits et 
		celles $\geq$ à 4096 bits, et ne prend en compte que les certificats RSA} 
		769 sont vulnérables.\\
		
		Vous pouvez trouver nos scripts parcourant un fichier contenant un 
		certificat sur chaque ligne, ou un dossier contenant des certificats sous 
		forme de fichiers PEM et nos résultats, dans le dossier consacré à l'audit des clés
		cryptographiques.\\
		
		Le format de nos résultats est : \\
		
		\textbf{COMPROMISED:} \textit{<haché\_du\_certificat>} \textit{<nom
		\_fichier\_corrompu (sous forme d'adresse IP)}\\
		
		Évidemment, nous ne mettons pas ces résultats sur le net puisqu'il indique 
		très clairement les adresses IP contenant le certificat friable, et sa clé
		privée (que l'on peut facilement retrouvé parmi la courte blacklist).\\
		
		Pour information, parmi les entreprises vulnérables nous trouvons les géants
		IBM et CISCO.
	
	\subsubsection{Implémentation}
		
		\paragraph{Version OpenSSL.\\}
		
		\paragraph{Fonction.\\}
		La fonction liée à cette norme est accessible sous le paquetage \texttt{bla/bla/bla}, dont les composantes principales sont listées en \textit{listing} \ref{codeAleatoire}.
		
		
		\begin{lstlisting}[style=customc,caption=codeAleatoire.c, label=codeAleatoire]
#include <stdio.h>
#define N 10
/* Block
 * comment */
 
int main()
{
    int i;
 
    // Line comment.
    puts("Hello world!");
 
    for (i = 0; i < N; i++)
    {
        puts("LaTeX is also great for programmers!");
    }
 
    return 0;
}
		\end{lstlisting}
		
		
		
		\paragraph{Audit.\\}

	\subsection{Audit 2 : Le cas LinuxMintDebianEdition sous Android}
	\subsubsection{Norme visée}
	\subsubsection{Faille}
	
		Récemment, en Août 2013 précisément, un patch de sécurité pour les 
		systèmes Android utilisant la version LinuxMintDebianEdition/OpenSSL, 
		dévoile une réparation du générateur de nombres pseudo-aléatoire (PRNG) 
		qui ne donnait pas suffisamment d'entropie
		\cite{alex2013android} \cite{bochum2013randomly}. \\
		
		Le patch indique que le PRNG de cette version d'OpenSSL utilise dorénavant 
		une combinaison de données plus ou moins prévisibles associées à 
		l'entropie générées par /dev/urandom. \\
		Mais sachant que le PRNG d'OpenSSL utilise lui-même /dev/urandom, on a du 
		mal à comprendre pourquoi en rajouter davantage.\\
	
		Eric Wong et Martin Boßlet apporte la solution sur leur site
		\cite{boblet2013android}, l'erreur 
		provient d'un bug "à la Debian", une simple ligne diffère de la version 
		officielle d'OpenSSL (utilisant SecureRandom) à celle de OpenSSL::Random 
		ce situant dans la fonction ssleay\_rand\_bytes. \\
	
		La cause est là même que celle de Debian, un patch de sécurité atteint la 
		source d'entropie du PRNG. Alors que tout semblait être rentré dans 
		l'ordre, un résidu de cette erreur reste dans cette version. Les 
		développeurs d'OpenSSL assure que ça n'a pas d'impact (ou alors très peu) 
		sur la sécurité globale. 
		Mais à cause de la mémoire non initialisé des systèmes Android, la source 
		d'entropie ne nous permet pas de générer des nombres non-prédictibles. \\
	
		La conséquence n'est pas aussi lourde que celle de Debian, tout d'abord 
		parce que le système Android est rarement utilisé pour du 
		chiffrement de données sensible, et une attaque par prédiction bien que
		plus rapide qu'une attaque par brute-force, reste infaisable. 
		Mais l'erreur est quand même là. \\

	
	\subsubsection{Implémentation}
		
		\paragraph{Version OpenSSL.\\}
		
		\paragraph{Fonction.\\}
		La fonction liée à cette norme est accessible sous le paquetage \texttt{bla/bla/bla}, dont les composantes principales sont listées en \textit{listing} \ref{codeAleatoire}.
		
		
		\begin{lstlisting}[style=customc,caption=codeAleatoire.c, label=codeAleatoire]
#include <stdio.h>
#define N 10
/* Block
 * comment */
 
int main()
{
    int i;
 
    // Line comment.
    puts("Hello world!");
 
    for (i = 0; i < N; i++)
    {
        puts("LaTeX is also great for programmers!");
    }
 
    return 0;
}
		\end{lstlisting}
		
		
		
		\paragraph{Audit.\\}

	\subsection{Audit 3 : Le cas LinuxMintDebianEdition sous Android}
	\subsubsection{Norme visée}
	\subsubsection{Faille}
	
	C'est le syndrome OpenSSH de Debian qui frappe une nouvelle fois.\\
	Du fait d'une parenthèse mal placée dans le code du fichier 
	/src/sys/kern/subr\_cprng.c, il s'avère que le générateur pseudo-aléatoire 
	de NetBSD 6.0 est bien moins solide que ce qui était attendu.\\
	Sa sortie est prévisible et il faut d'urgence changer les clés SSH qui ont été générées avec ce noyau.\\
	
	\subsubsection{Implémentation}
		
		\paragraph{Version OpenSSL.\\}
		
		\paragraph{Fonction.\\}
		La fonction liée à cette norme est accessible sous le paquetage \texttt{bla/bla/bla}, dont les composantes principales sont listées en \textit{listing} \ref{codeAleatoire}.
		
		
		\begin{lstlisting}[style=customc,caption=codeAleatoire.c, label=codeAleatoire]
#include <stdio.h>
#define N 10
/* Block
 * comment */
 
int main()
{
    int i;
 
    // Line comment.
    puts("Hello world!");
 
    for (i = 0; i < N; i++)
    {
        puts("LaTeX is also great for programmers!");
    }
 
    return 0;
}
		\end{lstlisting}
		
		
		
		\paragraph{Audit.\\}



\section{Recommandations générales}




%Si nécessaire, Code de figure : 
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.2]{images/logo_univ.png}
	\caption{Titre de Figure 1.1}
	\label{fig1}
\end{figure}